<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>前端规范参考：CSS规范</title>
  <link rel="stylesheet" href="css/main.css" />
  <link rel="stylesheet" href="css/codeView.css" />
  <script src="js/jquery.min.js"></script>
  <script src="js/jquery.snippet.min.js"></script>
</head>
<body>
<section id="instruction">
  <h1><span>前端规范参考：CSS规范</span></h1>
  <h2>代码风格</h2>
  <div>
    <ol>
      <li>
        <h3>基本语法</h3>
        <div>
          <ul class="listCompact">
            <li>
              <b>缩进：</b>
              <p>代码层级之间使用2个空格进行缩进。</p>
            </li>
            <li>
              <b>花括号：</b>
              <p>为了代码的易读性，在每个声明块的左花括号前添加一个空格，且声明块的右花括号应单独成行。</p>
<pre class="cssCode">
/* error */
.selector{
  font-size: 12px;
  color: #333;}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  font-size: 12px;
  color: #333;
}
</pre>
            </li>
            <li>
              <b>属性名结束：</b>
              <p>属性名的冒号后使用一个空格来分隔属性的名称和值（注意：属性和冒号之间没有空格）。</p>
<pre class="cssCode">
/* error */
h3 {
  font-weight:bold;
}
</pre>
<pre class="cssCode">
/* 推荐 */
h3 {
  font-weight: bold;
}
</pre>
            </li>
            <li>
              <b>声明结束：</b>
              <p>为了保证一致性和可扩展性，每个属性声明应该用分号结束。</p>
<pre class="cssCode">
/* error */
.test {
  display: block; height: 100px
}
</pre>
<pre class="cssCode">
/* 推荐 */
.test {
  display: block;
  height: 100px;
}
</pre>
            </li>
            <li>
              <b>选择器和声明分离：</b>
              <p>每个选择器和属性声明总是使用新的一行。</p>
<pre class="cssCode">
/* error */
a:focus, a:active {
  position: relative; top: 1px;
}
</pre>
<pre class="cssCode">
/* 推荐 */
h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
</pre>
            </li>
            <li>
              <b>规则分隔：</b>
              <p>每个规则块之间始终使用一个空行进行分隔。</p>
<pre class="cssCode">
/* error */
html {
  background: #fff;
}
body {
  margin: auto;
  width: 50%;
}
</pre>
<pre class="cssCode">
/* 推荐 */
html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
</pre>
            </li>
            <li>
              <b>十六进制表示法：</b>
              <p>十六进制值应该全部小写，例如：<code>#fff</code>。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</p>
              <p>尽量使用简写形式的十六进制值，例如：用 <code>#fff</code> 代替 <code>#ffffff</code>。</p>
<pre class="cssCode">
/* error */
.selector {
  color: #FFFFFF;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  color: #fff;
}
</pre>
            </li>
            <li>
              <b>0 和 单位 / 0 开头的小数：</b>
              <p>避免为 0 值指定单位，例如：用 <code>margin: 0;</code> 代替 <code>margin: 0px;</code>。</p>
              <p>省略小数点前面的 0（例如：<code>.5</code> 代替 <code>0.5</code>，<code>.5em</code> 代替 <code>0.5em</code>）。</p>
<pre class="cssCode">
/* error */
.selector {
  margin: 0px;
  padding: 0.5em;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  margin: 0;
  padding: .5em;
}
</pre>
            </li>
            <li>
              <b>关于逗号：</b>
              <p>对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如：<code>box-shadow</code>）。</p>
              <p>不要在 <code>rgb()</code>、<code>rgba()</code>、<code>hsl()</code>、<code>hsla()</code> 或 <code>rect()</code> 值的内部的逗号后面插入空格。这样利于从多个属性值（既加逗号也加空格）中区分多个颜色值（只加逗号，不加空格）。</p>
<pre class="cssCode">
/* error */
.selector {
  background-color: rgba(0, 0, 0, .5);
  box-shadow: 0 1px 2px #ccc,inset 0 1px 0 #fff;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;
}
</pre>
            </li>
            <li>
              <b>CSS引号：</b>
              <p>属性选择器或属性值用双引号（<code>""</code>），而不是单引号（<code>''</code>）。对于 URI 值（<code>url()</code>）不要使用引号。</p>
<pre class="cssCode">
/* error */
body {
  font-family: 'open sans', arial, sans-serif;
  background: url('images/bg.png');
}

.selector[name=pause]:before {
  content: 'pause';
}
</pre>
<pre class="cssCode">
/* 推荐 */
body {
  font-family: "open sans", arial, sans-serif;
  background: url(images/bg.png);
}

.selector[name="pause"]:before {
  content: "pause";
}
</pre>
            </li>
          </ul>
        </div>
      </li>
      <li>
        <h3>class 命名</h3>
        <div>
          <ul>
            <li>
              使用有意义的名称，避免使用表现形式的名称。
              <br>例如，使用 <code>.important</code> 代替 <code>.red</code>，使用 <code>.side</code> 代替 <code>.right</code>。
            </li>
            <li>
              命名应尽可能简短有效，并且意义明确。
              <br>例如，使用 <code>.nav</code> 代替 <code>.navgation</code>，使用 <code>.btn</code> 代替 <code>.button</code>。
            </li>
            <li>
              避免过度任意的简写。
              <br>例如，不要使用 <code>.s</code> 这类的过度简写来代替 <code>.search</code> 之类的命名。
            </li>
            <li>
              命名统一使用小写形式，切勿使用首字母大写的单词。
              <br>例如，使用 <code>england</code> 代替 <code>England</code> ，使用 <code>likeThis</code >代替 <code>LikeThis</code>。
            </li>
            <li>
              对于多个单词组合的名称使用驼峰式命名规则，而不要使用下划线或者破折号进行连接。
              <br>例如，<code>.demoImage</code>、<code>.errorStatus</code>。
            </li>
            <li>
              使用破折号“-”加前缀的方式来表示模块的层级关系或某一类元素。
              <br>层级关系，例如，<code>.floor-slide</code>、<code>.floor-hot</code>、<code>.floor-hot-brand</code>。
              <br>某一类元素，例如，<code>.icon-empty</code>、<code>.icon-delete</code>、<code>.icon-close</code>。
            </li>
            <li>
              使用 <code>j_</code> 为前缀的类名来表示那些需要参与脚本行为的元素，并且不要将这些 class 包含到 css 文件中。
              <br>例如，<code>j_slideList</code>、<code>j_slideNext</code>、<code>j_slidePrev</code>。
            </li>
          </ul>
        </div>
      </li>
      <li>
        <h3>合理的避免使用ID</h3>
        <div>
          <p>一般情况下ID不应该被应用于样式。</p>
          <p>ID的样式不能被复用并且每个页面中你只能使用一次ID。</p>
          <p>ID选择器权重很高。一个只包含一个ID选择器的权重高于包含1000个class类名的选择器，这使得它很奇怪。</p>
          <p>使用ID唯一有效的是确定网页或整个站点中的位置。尽管如此，我们应该始终考虑使用class，而不是id，除非只使用一次。</p>
<pre class="cssCode">
/* error */
#searchBox .key {
  font-size: 12px;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.searchBox .key {
  font-size: 12px;
}
</pre>
        </div>
      </li>
      <li>
        <h3>CSS选择器中避免标签名</h3>
        <div>
          <p>当构建选择器时应该使用清晰，准确和有语义的class类名，不要使用标签选择器。</p>
          <p>如果你只关心你的class类名，而不是你的代码元素，这样会更容易维护。</p>
          <p>从分离的角度考虑，在表现层中不应该分配html标记/语义。它可能是一个有序列表需要被改成一个无序列表，或者一个div将被转换成article。</p>
          <p>如果你只使用具有实际意义的class类名，并且不使用元素选择器，那么你只需要改变你的html标记，而不用改动你的CSS。</p>
<pre class="cssCode">
/* error */
.content > header > h2 {
  font-size: 2em;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.content-header > .title {
  font-size: 2em;
}
</pre>
        </div>
      </li>
      <li>
        <h3>尽可能的精确</h3>
        <div>
          <p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。</p>
          <p>有时，这可能会导致头痛的设计问题并且有时候可能会很耗性能。</p>
          <p>然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到DOM末端的选择器，你应该总是考虑直接子选择器。</p>
          <p>考虑下面的DOM：</p>
<pre class="htmlCode">
&lt;article class="news-wrap">
  &lt;span class="title">News event&lt;/span>
  &lt;div class="news-bd">
    &lt;div class="title">
      Check this out
    &lt;/div>

    &lt;p>This is a news article content&lt;/p>

    &lt;div class="news-teaser">
      &lt;div class="title">Buy this&lt;/div>
      &lt;div class="cont">Yey!&lt;/div>
    &lt;/div>
  &lt;/div>
&lt;/article>
</pre>
          <p>下面的CSS将应用于有 title 类的全部三个元素。然而，要解决 news-bd 类下的 title 类和 news-teaser 类下的 title 类下不同的样式，这将需要更精确的选择器再次重写他们的样式：</p>
<pre class="cssCode">
/* error */
.news-wrap .title {
  font-size: 2em;
}
</pre>
          <p>因此，建议尽可能使用直接子选择器来确保选择器的精确性：</p>
<pre class="cssCode">
/* 推荐 */
.news-wrap > .title {
  font-size: 2em;
}

.news-bd > .title {
  font-size: 1.5em;
}

.news-teaser > .title {
  font-size: 1.2em;
}
</pre>
        </div>
      </li>
      <li>
        <h3>使用缩写属性</h3>
        <div>
          <p>CSS提供了各种缩写属性（如 font 字体），合理的使用缩写属性对于代码效率和可读性是有很有帮助的：</p>
<pre class="cssCode">
/* error */
.selector {
  border-top-style: none;
  font-family: palatino, georgia, serif;
  font-size: 100%;
  line-height: 1.6;
  padding-bottom: 2em;
  padding-left: 1em;
  padding-right: 1em;
  padding-top: 0;
}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  border-top: 0;
  font: 100%/1.6 palatino, georgia, serif;
  padding: 0 1em 2em;
}
</pre>
          <p>使用缩写属性固然重要，但如果过度使用缩写形式的属性声明也会造成代码的混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。</p>
          <p>在使用缩写属性时，没有指定的值将会被设置为它的初始值。这就意味着，它将覆盖之前设置的值：</p>
<pre class="cssCode">
.element {
  background-color: red;
  background: url(images/bg.png) no-repeat top right;
}
</pre>
          <p>以上样式不会将 background 的 color 值设置为 red，而是 background-color 的默认值 transparent，因为第二条规则优先。</p>
          <p>因此，为了避免使用缩写属性而导致覆盖之前所设置的属性，我们应该避免为单一属性使用缩写形式的属性声明：</p>
<pre class="cssCode">
/* error */
.selector {
  margin: 0 0 10px;
  background: url(images/bg.png);
}
</pre>
<pre class="cssCode">
/* 推荐 */
.selector {
  margin-bottom: 10px;
  background-image: url(images/bg.png);
}
</pre>
        </div>
      </li>
      <li>
        <h3>属性的声明顺序</h3>
        <div>
          <p>这是选择器内书写 CSS 属性顺序的大致轮廓，也是为了保证更好的可读性和可扫描的重要措施。</p>
          <p>我们通过将 CSS 属性分为 <b>结构性属性</b> 和 <b>表现性属性</b> 两个分组，其中结构性属性应优先书写。</p>
          <p>有了两个分组之后，我们继续将各个组内的属性进行细分，来确定最后的分组情况：</p>
          <p><b>一、结构性属性</b></p>
          <ol class="listCompact">
            <li>定位属性：position, left, top, right, bottom, z-index</li>
            <li>布局属性：float, clear, display, flex, overflow, visibility</li>
            <li>盒模型：box-sizing, width, height, padding, border, margin</li>
          </ol>
          <p><b>二、表现性属性</b></p>
          <ol class="listCompact">
            <li>字体文本：font, text</li>
            <li>颜色背景：color, background, opacity</li>
            <li>其他属性（animation, transition等）</li>
          </ol>
          <p>在结构性属性中，由于定位可以从正常的文档流中移除元素，还能覆盖盒模型相关的样式，因此排在首位。</p>
          <p>而布局属性中的属性也会直接影响到元素在文档中的布局流以及显示方式，因此排在第二。</p>
          <p>而盒模型排在第三位，因为它决定了组件的尺寸和位置，相关属性顺序按照由内向外的顺序进行书写。</p>
          <p>在表现性属性中，由于这些属性只是影响组件的内部或者是不影响结构性的属性，因此排在后面。</p>
          <p>下面的选择器声明就是按照上面所规定的属性顺序进行的书写，有没有感觉代码很清晰呢：</p>
<pre class="cssCode autoHeight">
.declaration-order {
  /*  定位属性  */
  position: absolute;
  left: 0;
  top: 0;
  right: auto;
  bottom: auto;
  z-index: 100;

  /*  布局属性  */
  float: none;
  clear: all;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-end;
  order: 1;
  flex-grow: 1;
  overflow: hidden;

  /*  盒模型  */
  box-sizing: border-box;
  width: 80%;
  min-width: 800px;
  max-width: 1200px;
  height: auto;
  min-height: 100px;
  max-height: 300px;
  padding: 10px;
  padding-top: 20px;
  border: 2px solid #333;
  margin-top: 24px;

  /*  字体文本  */
  font: normal 13px "Helvetica Neue", sans-serif;
  line-height: 1.5em;
  letter-spacing: 0;
  text-align: left;
  text-indent: 2em;
  word-wrap: break-word;

  /*  颜色背景  */
  color: #333;
  background: #fff url(images/bg.png) no-repeat 0 0;
  background-size: 100% 100%;
  opacity: 1;

  /*  其他属性  */
  transition: all ease-out .4s;
}

.declaration-order::before {
  /*  伪元素的content属性优先书写  */
  content: "";

  /*  定位属性  */
  position: absolute;
  left: 0;
  top: 0;
  width: 16px;
  height: 16px;
}
</pre>
        </div>
      </li>
      <li>
        <h3>Hacks</h3>
        <div>
          <p>使用CSS Hacks，确实能够很容易地帮助我们解决浏览器的兼容性问题。但从长远来看，这将伤害我们的项目。在不到万不得已的时候，我们应该尽量避免使用这种方式，而应该寻找其他可行的变通方式来予以解决。</p>
        </div>
      </li>
    </ol>
  </div>
  <h2>Sass 说明</h2>
  <div>
    <ol>
      <li>
        <h3>文件格式</h3>
        <div>
          <p>为了符合 CSS 样式代码的编写习惯，以及方便从 CSS 代码到 Sass 代码的快速切换，我们约定统一使用 <code>.scss</code> 扩展名的 Sass 文件。</p>
<pre class="cssCode">
// error *.sass
.test-wrap
  display: block
  margin-top: 24px

  .title
    font-size: 1.2em
</pre>
<pre class="cssCode">
// 推荐 *.scss
.test-wrap {
  display: block;
  margin-top: 24px;

  .title {
    font-size: 1.2em;
  }
}
</pre>
        </div>
      </li>
      <li>
        <h3>代码注释</h3>
        <div>
          <p>我们建议按组书写注释。</p>
          <p>如果可以，按照功能的类别来对一组样式书写统一的注释，并独立成行。</p>
          <p>为了能够对不同组之间的代码进行较为明显的区分，并加强注释内容的阅读，我们建议在单行注释下添加一行分割线。</p>
<pre class="cssCode">
// header module
// ------------------------------------------------------------
.hd-logo { }
.hd-search { }
.hd-user { }

// footer module
// ------------------------------------------------------------
.ft-value { }
.ft-help { }
.ft-info { }

// country page
// ------------------------------------------------------------
.country-wrap { }
</pre>
        </div>
      </li>
      <li>
        <h3>Sass 中的选择器嵌套</h3>
        <div>
          <p>在 Sass 中我们可以嵌套选择器，这可以使得代码更加清洁和可读。</p>
          <p>不过在使用嵌套书写的过程中，应尽量避免嵌套没有任何内容的选择器。</p>
          <p>同时，你应该确保代码中的嵌套简洁易懂，最好控制在三层嵌套以内。</p>
<pre class="cssCode">
// error
.market-wrap {
  display: block;
}

.market-wrap > .title img {
  display: block;
  vertical-align: baseline;
}
</pre>
<pre class="cssCode">
// error
.market-wrap {
  display: block;

  > .title {
    img {
      display: block;
      vertical-align: baseline;
    }
  }
}
</pre>
<pre class="cssCode">
// 推荐
.market-wrap {
  display: block;

  > .title img {
    display: block;
    vertical-align: baseline;
  }
}
</pre>
        </div>
      </li>
      <li>
        <h3>嵌套中引入空行</h3>
        <div>
          <p>为了提高代码的整洁和可读，建议在嵌套选择器和 CSS 属性声明之间空一行。</p>
<pre class="cssCode">
// error
.market-wrap {
  display: block;
  > .title {
    height: 60px;
    background-color: #eee;
    img {
      display: block;
      vertical-align: baseline;
    }
    span {
      font-size: 1.2em;
    }
  }
}
</pre>
<pre class="cssCode">
// 推荐
.market-wrap {
  display: block;

  > .title {
    height: 60px;
    background-color: #eee;

    img {
      display: block;
      vertical-align: baseline;
    }

    span {
      font-size: 1.2em;
    }
  }
}
</pre>
        </div>
      </li>
      <li>
        <h3>媒体查询（Media query）的位置</h3>
        <div>
          <p>在 Sass 中，当你嵌套你的选择器时也可以使用上下文媒体查询。</p>
          <p>在 Sass 中，你可以在任何给定的嵌套层次中使用媒体查询。</p>
          <p>由此生成的 CSS 将被转换，这样的媒体查询将包裹选择器的形式呈现。</p>
          <p>这技术非常方便，有助于保持媒体查询属于的上下文。</p>
          <p>我们应将媒体查询尽可能放在相关规则的附近，不要将他们打包放在一个单一的样式文件中或者放在文档底部。</p>
          <p>如果你把他们分开了，将来只会被大家遗忘。</p>
<pre class="cssCode autoHeight">
// error

.page-wrap {
  font-size: 1.2rem;

  > .main {
    background-color: whitesmoke;

    > .latestNews {
      padding: 1rem;

      > .newsArticle {
        padding: 1rem;

        > .title {
          font-size: 2rem;
        }
      }
    }

    > .content {
      margin-top: 2rem;
      padding: 1rem;
    }
  }

  > .page-ft {
    margin-top: 2rem;
    font-size: 1rem;
  }
}

@media screen and (min-width: 641px) {
  .page-wrap {
    font-size: 1rem;

    > .main > .latestNews > .newsArticle > .title {
      font-size: 3rem;
    }

    > .page-ft {
      font-size: .8rem;
    }
  }
}
</pre>
<pre class="cssCode autoHeight">
// 推荐

.page-wrap {
  font-size: 1.2rem;

  @media screen and (min-width: 641px) {
    font-size: 1rem;
  }

  > .main {
    background-color: whitesmoke;

    > .latestNews {
      padding: 1rem;

      > .newsArticle {
        padding: 1rem;

        > .title {
          font-size: 2rem;

          @media screen and (min-width: 641px) {
            font-size: 3rem;
          }
        }
      }
    }

    > .content {
      margin-top: 2rem;
      padding: 1rem;
    }
  }

  > .page-ft {
    margin-top: 2rem;
    font-size: 1rem;

    @media screen and (min-width: 641px) {
      font-size: .8rem;
    }
  }
}
</pre>
        </div>
      </li>
      <li>
        <h3>嵌套顺序和父级选择器</h3>
        <div>
          <p>当使用 Sass 的嵌套功能时，重要的是要有一个明确的嵌套顺序，来保证代码的一致性。</p>
          <p>以下内容是一个 SCSS 块应具有的顺序：</p>
          <ol class="listCompact">
            <li>当前选择器的样式属性</li>
            <li>父级选择器的伪类选择器 (:first-letter, :hover, :active etc)</li>
            <li>父级选择器的伪类元素 (:before and :after)</li>
            <li>父级选择器的声明样式 (.selected, .active, .enlarged etc.)</li>
            <li>用 Sass 的上下文媒体查询</li>
            <li>子选择器作为最后的部分</li>
          </ol>
<pre class="cssCode autoHeight">
.product-wrap {
  // 1. 当前选择器的样式属性
  display: inline-block;
  padding: 1rem;
  color: grey;
  background-color: whitesmoke;

  // 2. 父级选择器的伪类选择器
  &:hover {
    color: black;
  }

  // 3. 父级选择器的伪元素
  &:before {
    content: "";
    display: block;
    border-top: 1px solid grey;
  }

  &:after {
    content: "";
    display: block;
    border-top: 1px solid grey;
  }

  // 4. 父级选择器的声明样式
  &.active {
    color: red;
    background-color: pink;

    // 4.2. 在样式声明中使用伪类选择器
    &:hover {
      color: darkred;
    }
  }

  // 5. 上下文媒体查询
  @media screen and (max-width: 640px) {
    display: block;
    font-size: 2em;
  }

  // 6. 子选择器
  > .content > .title {
    font-size: 1.2em;

    // 6.5. 在子选择器中使用上下文媒体查询
    @media screen and (max-width: 640px) {
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }
  }
}
</pre>
        </div>
      </li>
      <li>
        <h3>关于 _mixin.scss</h3>
        <div>
          <p>我们将项目中使用到的基础 Sass 代码，包括 @mixin、@function、%placeholder、variables，都放置在 _mixin.scss 文件中进行统一书写和管理。</p>
          <p>在正式进行开发工作之前，请务必认真阅读该文件中的内容，以达到样式书写最大程度的复用。</p>
        </div>
      </li>
    </ol>
  </div>
</section>
<script src="js/main.js"></script>
</body>
</html>
